<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<meta content='IE=edge' http-equiv='X-UA-Compatible'>
<meta content='width=device-width, initial-scale=1.0' name='viewport'>
<title>
Matthias Vallentin - A Garden Variety of Bloom Filters
</title>
<link href='/css/main.css' rel='stylesheet'>
<link href='/css/prism.css' rel='stylesheet'>
<script src='/js/all.js'></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src='https://www.googletagmanager.com/gtag/js?id=UA-1823891-1'></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-1823891-1');
</script>

<script type='text/x-mathjax-config'>
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    processEscapes: true
  },
  "HTML-CSS": { availableFonts: ["TeX"] }
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML' type='text/javascript'></script>

</head>
<body>
<main>
<div class='grid-x grid-padding-x align-center'>
<div class='cell medium-10 large-8'>
<div class='content'>
<h1>
A Garden Variety of Bloom Filters
</h1>
<div class='grid-x grid-padding-x align-justify margin-bottom-1'>
<div class='cell shrink'>
<span class='label radius'>
<i class='fa fa-calendar-o'></i>
2011-06-14
</span>
<span class='label radius warning'>
<i class='fa fa-calendar-plus-o'></i>
2013-07-17
</span>
</div>
<div class='cell shrink'>
<span class='label radius secondary'>
C++
</span>
<span class='label radius secondary'>
probability
</span>
<span class='label radius secondary'>
theory
</span>
</div>
</div>
<p>In this article, I explain how <strong>Bloom filters</strong> work and introduce several
variants that evolved as a result of extensive academic treatment of this
topic. Moreover, I present <a href="http://mavam.github.io/libbf">libbf</a>, an implementation of these Bloom
filters as a C++11 library.</p>

<blockquote>
  <p>Whenever you have a set or list, and space is an issue, a Bloom filter may be
a useful alternative.<br />
–Mitzenmacher</p>
</blockquote>

<h2 id="introduction">Introduction</h2>

<p>A <a href="http://en.wikipedia.org/wiki/Bloom_filter">Bloom filter</a> is a randomized
<a href="http://www.pittsburgh.intel-research.net/people/gibbons/talks-surveys/Synopsis-Data-Structures-Gibbons-Matias.pdf">synopsis data structure</a> that supports set membership queries.
Its space-efficient representation comes at the cost of <em>false positives</em>,
i.e., elements can erroneously be reported as members of the set. In practice,
the huge space savings often outweigh the false positives if kept at a
sufficiently low rate.</p>

<p>Bloom filters have received a great deal of attention not only by the research
community but also in practice. For example, <a href="http://src.chromium.org/viewvc/chrome/trunk/src/chrome/browser/safe_browsing/bloom_filter.h?view=log">Google Chrome</a> uses a
Bloom filter to represent a blacklist of dangerous URLs. Each time a user is
about to navigate to new page, the corresponding URL is mangled, hashed, and
then compared to a local Bloom filter that represents the set of all malicious
URLs.  If the Bloom filter reports that the URL is in the set, the browser
performs a <em>candidate check</em> by sending the hash of the URL to the Safebrowsing
server to confirm that the URL is indeed malicious. That is, all checks
are performed locally, but when the user surfs to a malicious URL, an extra
round trip to the Safebrowsing server occurs.</p>

<p>Another example is the squid web proxy which uses Bloom filters to represent
<a href="http://wiki.squid-cache.org/SquidFaq/CacheDigests">cache digests</a>, which
caching servers use to periodically exchange the objects they contain. There
are many more examples of Bloom filter applications, for instance in
peer-to-peer applications, routing protocols, <a href="http://en.wikipedia.org/wiki/IP_traceback">IP
traceback</a>, resource location, etc.
Broder and Mitzenmacher give a <a href="http://www.eecs.harvard.edu/~michaelm/postscripts/im2005b.pdf">good survey of network applications</a>.</p>

<h2 id="bloom-filters">Bloom Filters</h2>

<p>Before we delve into the discussion, let us agree on some common notation.</p>

<h3 id="terminology">Terminology</h3>

<ul>
  <li>Universe <script type="math/tex">U</script></li>
  <li><script type="math/tex">N</script> distinct items</li>
  <li><script type="math/tex">k</script> independent hash functions <script type="math/tex">h_1,\dots,h_k</script></li>
  <li>Vector <script type="math/tex">V</script> of <script type="math/tex">m</script> cells, i.e., <script type="math/tex">m = \lvert V \rvert</script></li>
  <li>Set:
    <ul>
      <li><script type="math/tex">S = \{x_1,\dots,x_n\}</script> where <script type="math/tex">x_i\in U</script> and <script type="math/tex">\lvert S\rvert = n</script></li>
    </ul>
  </li>
  <li>Multiset / Stream:
    <ul>
      <li><script type="math/tex">\mathcal{S} = \{x_1,\dots,x_n\}</script> where <script type="math/tex">x_i\in U</script> and
<script type="math/tex">|\mathcal{S}| = n</script></li>
      <li><script type="math/tex">C_x = \left\{ c_{h_1(x)},\dots,c_{h_k(x)} \right\}</script>
counters of <script type="math/tex">x</script></li>
      <li><script type="math/tex">f_x =</script> multiplicity (frequency) of <script type="math/tex">x\in\mathcal{S}</script></li>
    </ul>
  </li>
  <li>Bloom filter estimate denoted by hat:
<script type="math/tex">\widehat{S}, \widehat{\mathcal{S}}, \widehat{f}_x, \ldots</script></li>
  <li>Probability of a false positive (FP):
<script type="math/tex">\phi_P = \mathbb{P}\left(x\in \widehat{S} \vert x\notin S\right)</script></li>
  <li>Probability of a false negative (FN):
<script type="math/tex">\phi_N = \mathbb{P}\left(x\notin \widehat{S} \vert x\in S\right)</script></li>
  <li>Capacity <script type="math/tex">\kappa</script>, i.e., is the maximum number of items a Bloom filter
can hold until a given <script type="math/tex">\phi_P</script> can no longer be guaranteed</li>
  <li>A Bloom filter is <em>full</em> when then number of added items exceeds
<script type="math/tex">\kappa</script></li>
</ul>

<h3 id="basic">Basic</h3>

<p><img src="bf-basic.png" alt="The basic Bloom filter devised by Burton Bloom. To insert an item x, we set
the corresponding positions in the bit vector to
1" class="float-right padding-left-1" />
Burton Bloom introduced the original Bloom filter in 1970, which I refer to as
the <strong>basic Bloom filter</strong> from now on. The underlying data structure is a bit
vector <script type="math/tex">V</script> with <script type="math/tex">|V| = m = O(n)</script>
and <script type="math/tex">k</script> independent hash functions <script type="math/tex">h_1, \dots, h_k</script> that map
items in <script type="math/tex">U</script> to the range <script type="math/tex">[m] = \{1,\ldots,m\}</script>. (Unlike in the
implementation, I start at index 1 for the formal treatment.) All bits in
<script type="math/tex">V</script> are initialized to 0. Inserting an item <script type="math/tex">x\in S</script> involves setting the
bits at positions <script type="math/tex">h_1(x), \ldots, h_k(x)</script> in <script type="math/tex">V</script> to 1. Testing whether
an item <script type="math/tex">q\in U</script> is a member of <script type="math/tex">\widehat{S}</script> involves examining the bits
at positions <script type="math/tex">h_1(q),\dots,h_k(q)</script> in <script type="math/tex">V</script>. If any of these bits is 0
the Bloom filter reports <script type="math/tex">q\notin \widehat{S}</script>, and <script type="math/tex">q\in \widehat{S}</script>
otherwise. However, there remains some probability that <script type="math/tex">q\notin S</script>. This
type of error is a <em>false positive</em> (FP) and also known as <em>Bloom error</em>
<script type="math/tex">E_B</script>. It occurs because other elements in <script type="math/tex">S</script> also map to the same
positions.</p>

<p>To compute the probability of a Bloom error, we start off with an empty bit
vector <script type="math/tex">V</script> and insert an item. This is the same as independently (and
uniformly) choosing <script type="math/tex">k</script> bits and setting them to 1. Thereafter, the
probability that a certain bit in <script type="math/tex">V</script> is still 0 is</p>

<script type="math/tex; mode=display">\left(1 - \frac{1}{m}\right)^k.</script>

<p>Afer <script type="math/tex">n</script> insertions, the probability that a certain bit is 1 is</p>

<script type="math/tex; mode=display">1 - \left(1 - \frac{1}{m}\right)^{kn}.</script>

<p>Testing for membership involves hashing an item <script type="math/tex">k</script> times. Thus the
probability of a Bloom error is</p>

<script type="math/tex; mode=display">\begin{equation}
\mathbb{P}(E_B) = \left(1-\left(1-\frac{1}{m}\right)^{kn}\right)^k
\approx \left(1 - e^{-kn/m}\right)^k
\end{equation}</script>

<p>For fixed parameters <script type="math/tex">m</script> and <script type="math/tex">n</script>, the optimal value <script type="math/tex">k^*</script> that
minimizes this probability is</p>

<script type="math/tex; mode=display">k^* = \arg\min_k\;\mathbb{P}(E_B) =
\left\lfloor\frac{m}{n}\ln 2\right\rfloor</script>

<p>For <script type="math/tex">k^*</script>, we have hence <script type="math/tex">E_B = (0.619)^{m/n}</script>. Moreover, for a desired FP
probability <script type="math/tex">\phi_P</script> we can compute the number of required bits by
substituting the optimal value of <script type="math/tex">k</script>:</p>

<script type="math/tex; mode=display">m = -\frac{n\ln p}{(\ln 2)^2}.</script>

<h3 id="multisets">Multisets</h3>

<p>A basic Bloom filter can only represent a set, but neither allows for querying
the multiplicities of an item, nor does it support deleting entries. I use the
term <em>counting Bloom filter</em> to refer to variants of Bloom filters that
represent multisets rather than sets. Technically, a counting Bloom filter
extends a basic Bloom filter with width parameter <script type="math/tex">w</script>. (Note that the
<a href="http://pages.cs.wisc.edu/~cao/papers/summarycache.html">original counting Bloom filter</a> used cells with <script type="math/tex">w=4</script> only to support
deletion, not to count elements.)</p>

<h4 id="counting">Counting</h4>

<p><img src="bf-counting.png" alt="Each cell in the counting Bloom filter has a fixed bit width w. To insert
an item x, increment the counters C_x. To remove an item y, decrement its
counters C_y" class="float-right padding-left-1" />
In a counting Bloom filter, inserting an item corresponds to
incrementing a counter. Some variants also feature a decrement operation to
remove item from a set. <strong>But deletions necessarily introduce false
negative (FN) errors</strong>. Think about it this way: when you flip a set bit back
to 0 that was part of a <script type="math/tex">k</script> bits from another item, the Bloom filter will no
longer report <script type="math/tex">x\in\widehat{S}</script>. The probability of a FN is bounded by
<script type="math/tex">O(E_B)</script>.</p>

<p>Retrieving the count of an item <script type="math/tex">x\in\widehat{S}</script> involves computing its set
of counters <script type="math/tex">C_x</script> and returning the minimum value as frequency estimate
<script type="math/tex">\widehat{s}_x</script>. This query algorithm is also known as <em>minimum
selction</em> (MS).</p>

<p>There exist two main issues with counting Bloom filters:</p>

<ol>
  <li>Counter overflows</li>
  <li>The choice of <script type="math/tex">w</script></li>
</ol>

<p>The first problem exists when the counter value reaches <script type="math/tex">2^w - 1</script> and
cannot be incremented anymore. In this case, one typically stops counting
as opposed to overflowing and restarting at 0. However, this strategy
introduces <em>undercounts</em>, which we also refer to as FNs.</p>

<p>The second problem concerns the choice of the width parameter <script type="math/tex">w</script>. A large
<script type="math/tex">w</script> quickly diminishes the space savings from using of a Bloom filter. There
will also be a lot of unused space manifesting as unused zeros. A small
<script type="math/tex">w</script> may quickly lead to maximum counter values. As such, choosing
the right value is a difficult trade-off that depends on the distribution
of the data.</p>

<h4 id="bitwise">Bitwise</h4>

<p><img src="bf-bitwise.png" alt="The bitwise Bloom filter consists of l counting Bloom filters, each of which
represent w_i orders of magnitude of the entire counter. This Figure
illustrates a bitwise Bloom filter with w_i =
1." class="float-right padding-left-1" />
The <a href="ftp://ftp.cs.rochester.edu/pub/papers/theory/07.tr927.Bitwise_bloom_filter.pdf">bitwise Bloom filter</a> is a combination of <script type="math/tex">l</script> counting Bloom
filters with bit vectors <script type="math/tex">V_i</script>, each of which have <script type="math/tex">m_i</script> cells,
<script type="math/tex">k_i</script> hash functions, and width <script type="math/tex">w_i</script> where <script type="math/tex">i\in\{0,\dots,l-1\}</script>.
This variant aims at solving both of the overflow and space problem of the
counting Bloom filter.</p>

<p>To add an item <script type="math/tex">x</script>, first look at the counters in the first level
<script type="math/tex">V_0</script>. If there is enough room (i.e., width) available, perform
the increment.  If the counter overflows, insert <script type="math/tex">x</script> into <script type="math/tex">V_1</script> and
remove it from <script type="math/tex">V_0</script>. In this fashion, the counter value is conceptually
unbounded by adding more and more levels. However, the item has to be hashed
<script type="math/tex">l</script> times with a total of <script type="math/tex">\sum_{i=0}^{l-1} k_i</script> hash functions.</p>

<p>Retrieving the counter of an item involves combining the binary representation
of all levels. Let <script type="math/tex">c_i</script> be the counter value at level <script type="math/tex">i</script>. Then we
compute the counter value as</p>

<script type="math/tex; mode=display">C = \sum_{i=0}^{l-1} c_i 2^{\sum_{j=0}^i w_i}.</script>

<h4 id="spectral">Spectral</h4>

<p>The <a href="http://theory.stanford.edu/~matias/papers/sbf_tech_report.pdf">spectral Bloom filter</a> is an optimized version of the
counting Bloom filter. It consists of two extra algorithms in addition to MS
and introduces a more space-efficient data structure to represent counters.</p>

<ol>
  <li>
    <p>Let us review the MS algorithm. When querying an item <script type="math/tex">q\in U</script>, MS uses
the minimum counter value <script type="math/tex">m_q = \min_i\;C_q</script> as frequency estimate,
i.e., <script type="math/tex">\widehat{f}_q = m_q</script>. Cohen and Matias claim that <script type="math/tex">f_x \le m_x</script>
and <script type="math/tex">\mathbb{P}(\widehat{f}_x \neq m_x) = \mathbb{P}(E_B)</script> for all
<script type="math/tex">x\in S</script>.</p>
  </li>
  <li>
    <p>The second spectral algorithm is an optimization for the add operation. When
adding an item <script type="math/tex">x</script> to the Bloom filter, the <em>minimum increase</em> (MI)
algorithm only increments the minimum counter value(s)
<script type="math/tex">\tilde{C}_x = \min_i\;C_x</script>. The rationale behind this is that <script type="math/tex">m_x</script> is
always the most accurate count, thus MI results in the fewest possible
increment operations.</p>

    <p>Because not all counters are incremented on inserts, the effect of deletes
is significantly worse and the number of FNs becomes unbounded. Thus, the MI
algorithm should not be used when removing of items from a Bloom filter.
Cohen and Matias claim that <script type="math/tex">E_B^{MI} = O(E_B)</script> and that if <script type="math/tex">x</script> is drawn
uniformly from <script type="math/tex">U</script>, then <script type="math/tex">E_B^{MI} = E_B/k</script>.</p>
  </li>
  <li>
    <p>The third algorithm is <em>recurring minimum</em> (RM) and involves two Bloom
filters, <script type="math/tex">V_1</script> and <script type="math/tex">V_2</script>. The key insight behind RM is that items that
experience Bloom errors are less likely to have recurring minima counter
values. Cohen and Matias found empirically that this applies to
approximately 20% of the items. Such items with a unique minimum are
maintained in the second Bloom filter to reduce the discrepancy between
<script type="math/tex">f_x</script> and <script type="math/tex">\widehat{f}_x</script>.</p>

    <p>To query an item <script type="math/tex">q\in U</script> according to the RM algorithm, we look first
into the first Bloom filter and check if <script type="math/tex">q</script> has a recurring minimum. If
so, we return the minimum counter value. Otherwise we look the minimum
counter value from the second Bloom filter, unless it is 0. If it is 0
(i.e., does not exist), we return the minimum counter from the first Bloom
filter.</p>

    <p>Since all the items are inserted into the first bloom filter, the RM
optimization does at least as well as the MS algorithm, yet has usually
better error rates because a second filter holding fewer items is used for
items which experience higher error rates.</p>
  </li>
</ol>

<p>The fancy data-structure takes <script type="math/tex">N + o(N) + O(n)</script> space, where <script type="math/tex">n</script> is the
number of distinct items and <script type="math/tex">N = k\sum_{x\in S} \lceil \log f_x \rceil</script>.
For details, please refer to <a href="http://theory.stanford.edu/~matias/papers/sbf_tech_report.pdf">the paper</a>.</p>

<p>As an aside: a spectral Bloom filter with MS policy is conceptually isomorphic
to the <a href="http://en.wikipedia.org/wiki/Count-Min_sketch">Count-Min Sketch (CMS)</a>
when we partition the underlying bit vector into <script type="math/tex">k</script> sections, with each
<script type="math/tex">h_i</script> mapping to section <script type="math/tex">i</script>. Similarly, we can derive the
<a href="http://www.vldb2005.org/program/paper/tue/p13-cormode.pdf">Fast-AMS</a> sketch by taking the median of the <script type="math/tex">k</script> counters instead
of their minimum.</p>

<h3 id="aging">Aging</h3>

<p>A problem all the above Bloom filter variants is that they eventually fill up
over time when dealing with a large set or stream of data. This means that at
some point the Bloom filter becomes unusable due to its high error rates. There
exist various scenarios where one would like to “age out” old items that have
been added a long time ago. For example, we might want to estimate only recent
items or we have a very limited amount of space available.</p>

<p>Although counting Bloom filters have a delete operation, it is often impossible
to retain old items in memory. Thus we do not know their counter positions in
the bit vector anymore, otherwise we would simply decrement their count. What
we want is a Bloom filter that has <em>sliding window</em> semantics, as
illustrated by the Figure below.</p>

<p><img src="sliding-window.png" alt="In a sliding window scenario, an insert operation for a new item x_7 would
ideally delete an old item x_0." class="float-center" /></p>

<p>To support a sliding window, we would like a Bloom filter which acts like
a FIFO. In the following, I discuss two different Bloom filter flavors that
aim at providing this property.</p>

<h4 id="stable">Stable</h4>

<p>The <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.85.1569">stable Bloom filter</a> is essentially a basic Bloom filter with an
underlying bit vector with a fixed cell width <script type="math/tex">w</script>. However, counters do not
represent the multiplicities of the items but rather their age. Thus the
interface supports only set membership queries.</p>

<p>To insert an item, we decrement <script type="math/tex">d</script> cells chosen uniformly at random.
Thereafter, we set the counters of all <script type="math/tex">k</script> cells to their maximum value of
<script type="math/tex">2^w - 1</script>.</p>

<p>Deng and Rafiei have shown that the fraction of zeros will eventually become
constant. When having reached this <em>stable point</em>, the approximate
probability of a Bloom error is</p>

<script type="math/tex; mode=display">\phi_P \approx 1 - \frac{1}{1+\frac{1}{d(1/k-1/m)}} = \frac{1}{d/k-d/m+1}</script>

<h4 id="a2">A<sup>2</sup></h4>

<p>The <a href="http://portal.acm.org/citation.cfm?id=1685986"><script type="math/tex">A^2</script> Bloom filter</a>, also known as <strong>active-active buffering</strong>,
provides another type of FIFO. It uses two single-bit vectors <script type="math/tex">V_1</script> and
<script type="math/tex">V_2</script> where <script type="math/tex">|V_1| = |V_2| = \frac{m}{2}</script>. Unlike the spectral RM
algorithm, one Bloom filter is not a subset of the other, so an item can be in
either Bloom filter.</p>

<p>The algorithm works as follows. To query for an item, return true if <script type="math/tex">q</script>
exists in either <script type="math/tex">V_1</script> or <script type="math/tex">V_2</script>. To insert an item <script type="math/tex">x</script>, simply return
if it already exists in <script type="math/tex">V_1</script>. Otherwise insert it in <script type="math/tex">V_1</script> and test
whether <script type="math/tex">V_1</script> has reached its capacity. If it is full, flush <script type="math/tex">V_2</script> and swap
<script type="math/tex">V_1</script> and <script type="math/tex">V_2</script>. Thereafter insert the item in <script type="math/tex">V_1</script> (the old <script type="math/tex">V_2</script>).</p>

<p>One advantage of the <script type="math/tex">A^2</script> Bloom filter is space-efficiency, since one bit
vector is always full. Let the subscript <script type="math/tex">a</script> denote the value of the
<script type="math/tex">A^2</script> Bloom filter. The probability of a Bloom error is</p>

<script type="math/tex; mode=display">{\phi_P}_a = 1 - \sqrt{1-\phi_P}</script>

<p>and the optimal value for <script type="math/tex">k_a</script> and <script type="math/tex">\kappa_a</script> are:</p>

<script type="math/tex; mode=display">k_a^* =
\left\lfloor -\log_2\left(1-\sqrt{1-\phi_P}\right) \right\rfloor
\qquad
\kappa_a^* = \left\lfloor \frac{m}{2k_a^*} \ln2 \right\rfloor</script>

<h2 id="libbf">libbf</h2>

<p>As part of a class project for the course <a href="http://www.cs.berkeley.edu/~satishr/cs270/">Combinatorial Algorithms and Data
Structures</a> in Spring 2011 at UC
Berkeley, I decided to write a <a href="http://en.wikipedia.org/wiki/C%2B%2B0x">C++11</a>
<strong>lib</strong>rary of <strong>B</strong>loom <strong>f</strong>ilters, <a href="http://mavam.github.io/libbf">libbf</a>, which implements the
above discussed Bloom filters. <a href="/course-work/cs270-s11.pdf">Slides</a> of the
final presentation are also available; they go a little deeper into the
algorithmic details. Note that the slides cover an early version of the
implementation; the API has changed significantly since.</p>

<h2 id="related-work">Related Work</h2>

<p>I only presented a few Bloom filter types in this article, but active research
in this field yielded many more variations. For example, the <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.151.8477">dynamic</a>
and <a href="http://gsd.di.uminho.pt/members/cbm/ps/dbloom.pdf">scalable</a> Bloom filter are two variants that grow dynamically
as soon as more items are added. Bloom filters can also be
<a href="http://www.eecs.harvard.edu/~michaelm/NEWWORK/postscripts/cbf.pdf">compressed</a>, e.g., when sending them over the network.
<a href="http://www.siam.org/proceedings/alenex/2006/alx06_004akirsch.pdf">Distance-sensitive</a> Bloom filters give more than a binary answer or
count when asking for an item: they also return if an item is close to another
item in the set. Finally, there exist <a href="http://webee.technion.ac.il/~ayellet/Ps/nelson.pdf">Bloomier</a> filters which
extend the set membership query model and counting notion to computations of
arbitrary functions.</p>

<p><a href="http://en.wikipedia.org/wiki/Cuckoo_hashing">Cuckoo hashing</a> is a related
space-efficient alternative to Bloom filters. Moreover, Adam Langley has some
<a href="http://www.imperialviolet.org/2011/04/29/filters.html">interesting thoughts</a>
on Golomb Compressed Sets. Finally, Ilya’s article on <a href="http://highlyscalable.wordpress.com/2012/05/01/probabilistic-structures-web-analytics-data-mining">probabilistic data
structures for data mining</a> presents a nice follow-up read.</p>

<h3 id="acknowledgements">Acknowledgements</h3>

<p>I would like to thank Ryan Killea and Tobin Baker for their useful feedback.</p>


<div class='separator-center margin-bottom-2'></div>
<a class='button expanded hollow radius' href='#' id='show-comments' onclick='disqus();'>
Load Comments
</a>
<div id='disqus_thread'>
<script>
  var disqus_shortname = 'mavam';
  var disqus_config = function () {
    this.page.url = 'http://matthias.vallentin.net/blog/2011/06/a-garden-variety-of-bloom-filters/';
    this.page.identifier = '';
  };
  var disqus_loaded = false;
  function disqus() {
    if (!disqus_loaded){
      disqus_loaded = true;
      var d = document, s = d.createElement('script');
      s.src = '//' + disqus_shortname +'.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
      // Hide the button after loading comments.
      d.getElementById('show-comments').style.display = 'none';
      return false;
    }
  };
</script>
</div>


</div>
</div>
</div>
</main>
<footer>
<div class='grid-x grid-padding-x'>
<div class='cell shrink show-for-medium'>
<div class='copyright'>
<i class='fa fa-copyright'></i>
2007-2018 Matthias Vallentin
</div>

</div>
<div class='cell auto'>
<ul class='menu vertical medium-horizontal'>
<li>
<a href='/#home'>
Home
</a>
</li>
<li>
<a href='/#bio'>
Bio
</a>
</li>
<li>
<a href='/#research'>
Research
</a>
</li>
<li>
<a href='/#presentations'>
Presentations
</a>
</li>
<li>
<a href='/#coursework'>
Course Work
</a>
</li>
<li>
<a href='/#projects'>
Projects
</a>
</li>
<li>
<a href='/#teaching'>
Teaching
</a>
</li>
<li>
<a href='/#blog'>
Blog
</a>
</li>
</ul>
</div>
<div class='cell shrink show-for-medium'>
<ul class='menu social'>
<li>
<a href='mailto:matthias@berkeley.edu'>
<i class='fa fa-envelope'></i>
</a>
</li>
<li>
<a href='https://www.linkedin.com/in/matthias-vallentin/'>
<i class='fa fa-linkedin'></i>
</a>
</li>
<li>
<a href='https://github.com/mavam'>
<i class='fa fa-github'></i>
</a>
</li>
</ul>

</div>
</div>
<div class='hide-for-medium'>
<ul class='menu social'>
<li>
<a href='mailto:matthias@berkeley.edu'>
<i class='fa fa-envelope'></i>
</a>
</li>
<li>
<a href='https://www.linkedin.com/in/matthias-vallentin/'>
<i class='fa fa-linkedin'></i>
</a>
</li>
<li>
<a href='https://github.com/mavam'>
<i class='fa fa-github'></i>
</a>
</li>
</ul>

<div class='copyright'>
<i class='fa fa-copyright'></i>
2007-2018 Matthias Vallentin
</div>

</div>

</footer>
<!-- Enable Foundation -->
<script>
  $(document).foundation();
</script>

</body>
</html>
